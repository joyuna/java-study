# chapter5. 참조 타입
## 5.1 데이터 타입 분류
- 기본 타입(primitive type)
  - 기본 타입을 이용해서 선언된 변수는 `실제 값을 변수 안에 저장한다.`
    - 정수
    - 실수
    - 문자
    - 논리 리터럴
- 참조 타입(reference type)
  - 참조 타입을 이용해서 선언된 변수는 `힙 영역이나 메소드 영역의 메모리의 번지를 값으로 갖는다.`
  즉, 주소를 통해 객체를 참조한다.
    - 배열
    - 열거
    - 클래스
    - 인터페이스

## 5.2 메모리 사용 영역
- java.exe로 JVM이 시작되면 JVM은 운영체제에서 할당받은 메모리 영역(Runtime Data Area)을 세부 영역으로 구분해서 사용한다.
### 1. 메소드(Method) 영역
- JVM이 시작할 때 생성된다.
- 모든 스레드가 공유하는 영역이다.
- 코드에서 사용되는 클래스(~.class)들을 클래스 로더로 읽어 클래스별로 분류해서 저장한다.
  - 런타임 상수풀(runtime constant pool)
  - 필드(field) 데이터
  - 메소드(method) 데이터
  - 메소드 코드
  - 생성자(constructor) 코드 등

### 2. 힙(Heap) 영역
- 객체와 배열이 생성되는 영역이다.
- 힙 영역에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
- 사용되지 않는 객체는 Garbage Collector 가 힙 영역에서 자동으로 제거한다.

### 3. JVM 스택(Stack) 영역
- 스레드가 시작될 때 할당된다.
- 각 스레드마다 하나씩 존재한다.
  > #### 🔍 프로세스와 스레드
  > - 프로세스(process)
  >   - 실행 중인 프로그램
  >   - 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말한다.
  >   
  > - 스레드(thread)
  >   - 프로세스(process)내에서 실제로 작업을 수행하는 주체를 말한다.
  >   - 모든 프로세스에는 한 개 이상의 스레드가 존재한다.
  >   - 두 개 이상의 스레드를 가지는 프로세스는 멀티스레드 프로세스(multi-threaded process)라고 한다.
  > 
  > _reference. [TCP SCHOOL 스레드의 개념](http://www.tcpschool.com/java/java_thread_concept)_

- JVM 스택은 메소드를 호출할 때마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행한다.
  - 프레임 내부에는 로컬 변수 스택이 있는데, 기본 타입 변수와 참조 타입 변수가 추가(push)되거나 제거(pop)된다.
  - 변수가 이 영역에 생성되는 시점은 최초로 변수에 값이 저장(초기화)될 때이다.
  - 변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.

## 5.3 참조 변수의 ==, != 연산
- 기본 타입 변수의 ==, != 연산
  - 변수의 값이 같은지, 아닌지 알아볼 때 사용된다.
- 참조 변수의 ==, != 연산
  - 동일한 객체를 참조하는지, 다른 객체를 참조하는지 알아볼 때 사용된다.
  - 참조 타입 변수의 값은 힙 영역의 객체 주소이므로 결국 주소 값을 비교하는 것이 된다.
  - 동일한 주소 값을 갖고 있는 것은 동일한 객체를 참조한다는 의미이다.
    - 동일한 객체를 참조 하는 경우 == 연산의 결과는 true 이고 != 연산의 결과는 false 이다.
    ```java
    refVar1과 refVar2가 서로 다른 객체를 참조하고 있을 때,

    refVar1 == refVar2 결과: false
    fefVar1 != refVar2 결과: true
    ```
    ```java
    refVar2과 refVar3가 동일한 객체를 참조하고 있을 때,

    refVar2 == refVar3 결과: true
    fefVar2 != refVar3 결과: false
    ```
    
## 5.4 null과 NullPointerException
### 1. null
- 참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null(널)값을 가질 수 있다.
- null 값도 초기값으로 사용할 수 있다.
- null 로 초기화된 참조 변수는 스택 영역에 생성된다.

### 2. NullPointerException
- 자바는 프로그램 실행 도중에 발생하는 오류를 예외(Exception)라고 부른다.
- 참조 변수를 사용하면서 가장 많이 발생하는 예외 중 하나가 NullPointerException 이다.
  - 참조 타입 변수를 잘못 사용하면 발생한다.
  - 참조 타입 변수가 null을 가지고 있을 경우, 참조 타입 변수는 사용할 수 없다. 사용하게 되면 NullPointerException이 발생한다.

## 5.5 String 타입
- String 변수에 문자열을 저장한다는 말을 정확한게 아니다.
  - 문자열은 String 객체로 생성되고, 변수는 String 객체를 참조하는게 정확한 표현이다.
  - 문자열 리터럴이 동일하면 Sting 객체는 공유된다.
- new 연산자(객체 생성 연산자)를 사용해 힙 영역에 새로운 객체를 만들 수 있다.
- 문자열이 동일한지 비교하는 메소드 
  - equals() 메소드
    ```java
    boolean result = string1.equals(string2);
    // string1 => 원본 문자열, string2 => 비교 문자열
    ```
    
- String 변수는 참조 타입이므로 초기값으로 null을 대입할 수 있다.

## 5.6 배열 타입
### 1. 배열이란?
- 같은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스(index)를 부여해 놓은 자료구조이다.
  - 인덱스는 각 항목의 데이터를 읽거나, 저장하는데 사용된다.
  - 배열 이름 옆에 대괄호 []에 기입된다.
    ```java
    ex) score[인덱스]
    ```
- 같은 타입의 데이터만 저장할 수 있다.
- 선언과 동시에 저장할 수 있는 데이터 타입이 결정된다.
- 다른 타입의 값을 저장하려고 하면 타입 불일치(Type mismatch) 컴파일 오류가 발생한다.
- 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다.
  - 길이를 수정할 수 없기 때문에 길이에 맞는 새로운 배열을 생성하고, 기존 배열 항목을 새 배열로 복사해야 한다.

### 2. 배열 선언
- 배열을 사용하기 위해서 배열 변수를 선언한다.
  ```java
  선언방법1. 타입[] 변수;
       ex) int[] intArray;
           double[] doubleArray;
           String[] strArray;
     
  선언방법2. 타입 변수[];
       ex) int intArray[];
           double doubleArray[];
           String strArray[];
   ```
- 배열 변수는 참조 변수에 속한다.
- 배열도 객체이기 때문에 힙 영역에 생성된다.
- 배열 변수는 힙 영역의 배열 객체를 참조하게 된다.
- 참조할 배열 객체가 없으면 배열 변수는 null 값으로 초기화될 수 있다.
  ```java
  타입[] 변수 = null;
  ```
  
- 배열 변수는 배열을 생성하고 참조하는 상태에서 값을 저장하거나 읽어야 한다.

### 3. 값 목록으로 배열 생성
- 배열 항목에 저장될 값의 목록이 있다면, 다음과 같이 간단하게 배열 객체를 만들 수 있다.
  ```java
  String[] names = { "신용권", "홍길동", "감자바" };   
  ```

- 배열 변수를 이미 선언한 후에 다른 실행문에서 중괄호 {}를 사용한 배열 생성은 허용되지 않는다.
  ```java
  타입[] 변수;
  변수 = { 값0, 값1, 값2, 값3, ... }; // 컴파일 에러
  ```
  
- 배열 변수를 미리 선언한 후, 값 목록들이 나중에 결정되는 상황엔 new 연산자를 사용해서 값 목록을 지정해주면 된다.
  ```java
  변수 = new 타입[] { 값0, 값1, 값2, 값3, ... };
  
  ex) String[] names = null;
      names = new String[] { "신용권", "홍길동", "감자바" };
  ```
  ```java
  int add(int[] scores) {...}
  ---------------------------------------------
  int result = add({95, 85, 90}); // 컴파일 에러
  int result = add(new int[] {95, 85, 90});
  ```
  
### 4. new 연산자로 배열 생성
- 값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶다면 new 연산자로 배열 객체를 생성시킬 수 있다.
- new 연산자로 배열을 생성할 경우에는 이미 배열 변수가 선언된 후에도 가능하다.
  ```java
  타입[] 변수 = new 타입[길이];
  ```
  ```java
  타입[] 변수 = null;
  변수 = new 타입[길이];
  ```

- new 연산자로 배열을 처음 생성할 경우, 배열은 자동적으로 기본값으로 초기화 된다.
- 배열이 생성되고 나서 새로운 값을 저장하려면 대입 연산자를 사용하면 된다.
  ```java
  변수[인덱스] = 값;
  
  ex) int[] scores = new int[3];
      scores[0] = 83;
      scores[1] = 90;
      scores[2] = 75;
  ```
### 💡 타입별 배열의 초기값 💡
| 분류        | 데이터 타입    | 초기값      |
|:----------|:----------|:---------|
| 기본 타입(정수) | byte[]    | 0        |
|           | char[]    | '\u0000' |
|           | short[]   | 0        |
|           | int[]     | 0        |
|           | long[]    | 0L       |
| 기본 타입(실수) | float[]   | 0.0F     |
|           | double[]  | 0.0      |
| 기본 타입(논리) | boolean[] | false    |
| 참조 타입     | 클래스[]     | null     |
|           | 인터페이스[]   | null     |   

### 5. 배열 길이
- 배열의 길이
  - 배열에 저장할 수 있는 전체 항목 수를 말한다.
- 배열의 길이를 얻으려면 배열 객체의 length 필드(객체 내부의 데이터)를 읽으면 된다.
  ```java
  배열변수.length;
  
  ex) int[] intArray = { 10, 20, 30 };
      int num = intArray.length;
  ```
- length 필드는 읽기 전용 필드이기 때문에 값을 바꿀 수가 없다.
- 배열의 인덱스 범위는 0 ~ (길이 - 1)이다. 만약 인덱스를 초과해서 사용하면 ArrayIndexOutOfBoundsException이 발생한다.

### 6. 커맨드 라인 입력
- "java 클래스"로 프로그램을 실행하면 JVM은 길이가 0인 String 배열을 먼저 생성하고 main() 메소드를 호출할 때 매개값으로 전달한다.
- "java 클래스" 뒤에 공백으로 구분된 문자열 목록을 주고 실행하면, 문자열 목록으로 구성된 String[] 배열이 생성되고 main() 메소드를 호출할 때 매개값으로 전달된다.
- main() 메소드는 String[] args 매개 변수를 통해서 커맨드 라인에서 입력된 데이터의 수(배열의 길이)와 데이터(배열의 항목 값)를 알 수 있게 된다.
- 문자열은 산술 연산을 할 수 없기 때문에 문자열은 Integer.parseInt() 메소드를 이용해서 정수로 변환시킨다.
  ```java
  int 변수 = Integer.parseint("정수로 변환 가능한 문자열"); // 정수로 변환 후 변수에 저장한다.
  ```
  
- 정수로 변환할 수 없는 문자열이 주어졌을 경우에는 NumberFormatException 실행 예외가 발생한다.

### 7. 다차원 배열
- 형과 열로 구성된 배열을 2차원 배열이라고 한다.
- 2차원 배열은 수학의 행렬을 떠올리면 된다.
- 가로 인덱스와 세로 인덱스를 사용한다.
  ```java
  int[][] scores = new int[2][3];
  
  scores.length // 2(배열 A의 길이)
  scores[0].length // 3(배열 B의 길이)
  scores[1].length // 3(배열 C의 길이)
  ```
  
### 8. 객체를 참조하는 배열
- Sting[] 배열의 항목도 String 변수와 동일하게 취급되어야 한다.
  - 배열 항목 간에 문자열을 비교하기 위해서는 == 연산자 대신 equals() 메소드를 사용해야 한다.
  - ==는 객체의 번지 비교에 사용해야 한다.
```java
String[] strArray = new String[3]
strArray[0] = "Java";
strArray[1] = "Java";
strArray[2] = new String("Java");

System.out.println(strArray[0] == strArray[1]);      // true(같은 객체를 참조)
System.out.println(strArray[0]) == strArray[2];      // false(다른 객체를 참조)
System.out.println(strArray[0].equals(strArray[2])); // true(문자열이 동일)
```

### 9. 배열 복사
- 배열은 한 번 생성하면 크기를 변경할 수 없기 때문에 더 많은 저장 공간이 필요하다면 보다 큰 배열을 새로 만들고 이전 배열로부터 항목 값들을 복사해야 한다.
- 배열 간의 항목 값들을 복사하려면 아래 두가지 방법을 사용하면 된다.
  - for문
  - System.arraycopy() 메소드
    - 호출하는 법
      ```java
      System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
      ```
      - src 매개값 :  원본 배열
      - srcPos : 원본 배열에서 복사할 항목의 시작 인덱스
      - dest 매개값 : 새 배열
      - destPos : 새 배열에서 붙여넣을 시작 인덱스
      - length : 복사할 개수
- 복사되지 않은 항목은 배열의 기본 초기값으로 유지된다.
- 참조 타입 배열일 경우, 배열 복사가 되면 복사되는 값이 객체의 번지이므로 새 배열의 항목은 이전 배열의 항목이 참조하는 객체와 동일하다. 이것을 `얕은 복사(shallow copy)`라고 한다.
- 참조하는 객체도 별도로 생성하는 것을 `깊은 복사(deep copy)`라고 말한다.

### 10. 향상된 for문
```java
for(타입 변수 : 배열) {
    실행문;
}
```
- 향상된 for문은 반복 실행을 하기 위해 카운터 변수와 증감식을 사용하지 않는다.
- 배열 및 컬렉션 항목의 개수만큼 반복하고, 자동적으로 for문을 빠져나간다.
- 향상된 for문의 실행 흐름
  1. for문이 처음 실행될 때 배열에서 가져올 첫 번째 값이 존재하는지 평가한다.
  2. 가져올 값이 존재하면 해당값을 변수에 저장한다.
  3. 그리고 실행문을 실행한다.
  4. 블록 내부의 실행문이 모두 실행되면 다시 루프를 돌아 배열에서 가져올 다음 값이 존재하는지 평가한다.
  5. 다음 항목이 존재하면 다시 진행하고, 가져올 다음 항목이 없으면 for문이 종료된다.

## 5.7 열거 타입
- 열거 타입(enumeration type)은 한정된 값만을 갖는 데이터 타입이다.
- 열거 타입은 몇 개의 열거 상수(enumeration constant)중에서 하나의 상수를 저장하는 데이터 타입니다.

### 1. 열거 타입 선언
- 열거 타입 이름
  - 열거 타입의 이름으로 소스 파일(.java)을 생성해야 한다.
  - 열거 타입의 이름은 관례적으로 첫 문자를 대문자로 하고 나머지는 소문자로 구성한다.
  - 열거 타입의 이름은 소스 파일명과 대소문자가 모두 일치해야 한다.
- public enum 키워드
  - 열거 타입을 선언하기 위한 키워드이다.
  - 반드시 소문자로 작성해야 한다.
  ```java
  public enum 열거타입이름 {...}
  ```
  
- 열거 타입을 선언했으면 열거 상수를 선언하면 된다.
- 열거 상수
  - 열거 상수는 열거 타입의 값으로 사용된다.
  - 열거 상수는 모두 대문자로 작성한다.
  - 열거 상수가 여러 단어로 구성될 경우에는 단어 사이를 밑줄(_)로 연결하는 것이 관례이다.

### 2. 열거 타입 변수
- 열거 타입도 하나의 데이터 타입이므로 변수를 선언하고 사용해야 한다.
  - 열거 타입 변수 선언하는 방법
    ```java
    열거타입 변수;
    ```
  
- 열거 타입 변수 선언 후 열거 상수를 저장할 수 있다.
  - 열거 상수는 단독으로 사용할 수 없고 반드시 `열거타입.열거상수`로 사용된다.
    ```java
    열거타입 변수 = 열거타입.열거상수;
    ```
  - 열거 타입은 참조 타입이기 때문에 열거 타입 변수는 null 값을 저장할 수 있다.
    - 열거 상수는 객체이다.

### 3. 열거 객체의 메소드
- 열거 객체는 열거 상수의 문자열을 내부 데이터로 가지고 있다.
  - 메소드는 java.lang.Enum 클래스에 선언돼있다.
  - 열거 객체에서 사용할 수 있는 이유는 모든 열거 타입은 컴파일 시에 Enum 클래스를 상속하게 되어 있기 때문이다.

| 리턴 타입  | 메소드(매개 변수)           | 설명                    |
|:-------|:---------------------|:----------------------|
| String | name()               | 열거 객체의 문자열을 리턴        |
| int    | ordinal()            | 열거 객체의 순번(0부터 시작)을 리턴 |
| int    | compareTo()          | 열거 객체를 비교해서 순번 차이를 리턴 |
| 열거 타입  | valueOf(String name) | 주어진 문자열의 열거 객체를 리턴    |
| 열거 배열  | values()             | 모든 열거 객체들을 배열로 리턴     |
  
- name() 메소드
  - 열거 객체가 가지고 있는 문자열을 리턴한다.
  - 리턴되는 문자열은 열거 타입을 정의할 때 사용한 상수 이름과 동일하다.
    ```java
    Week today = Week.SUNDAY;
    String name = today.name();
    ```
    
- ordinal() 메소드
  - 전체 열거 객체 중 몇 번째 열거 객체인지 알려준다.
  - 열거 객체의 순번은 열거 타입을 정의할 때 주어진 순번을 말하는데, 0번부터 시작한다.
    ```java
    Week today = Week.SUNDAY;
    int ordinal = today.ordinal();
    ```
    
- compareTo() 메소드
  - 매개값으로 주어진 열거 객체를 기준으로 전후로 몇 번째 위치하는지를 비교한다.
  - 열거 객체가 매개값의 열거 객체보다 순번이 빠르면 `음수`가 리턴된다.
  - 열거 객체가 매개값의 열거 객체보다 순번이 늦다면 `양수`가 리턴된다.
    ```java
    Week day1 = Week.MONDAY;
    Week day2 = Week.WEDNESDAY;
    int result1 = day.compareTo(day2); // -2
    int result2 = day.compareTo(day1); // 2
    ```
    
- valueOf() 메소드
  - 매개값으로 주어지는 문자열과 동일한 문자열을 가지는 열거 객체를 리턴한다.
  - 외부로부터 문자열을 입력받아 열거 객체로 변환할 때 유용하게 사용할 수 있다.
    ```java
    Week weekDay = Week.valueOf("SATURDAY");
    ```
    
- values() 메소드
  - 열거 타입의 모든 열거 객체들을 배열로 만들어 리턴한다.
      ```java
    Week[] days = Week.values();
    for(Week day : days) {
    System.out.println(day);
    }
    ```